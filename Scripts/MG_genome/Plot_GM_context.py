"""
Plot genomic synteny context (present and absent) for GWAS-significant Panaroo clusters.

Features:
- Reads per-cluster synteny (*.tsv) plus signatures and consensus neighbor files generated by Check_GM_context.
- Builds tile plots of local gene/product (or cluster) context across samples.
- Optionally includes absent samples with absence_class borders (annotation_issue, region_missing, etc.).
- Highlights GWAS direction: center tile border (green=match, red=mismatch, gray=unknown).
- Adds bar plots for signature frequencies, absence summaries, and consensus neighbor clusters.
Outputs:
- *_synteny_tiles_products.png / *_synteny_tiles_clusters.png
- *_signature_bars.png
- *_absence_summary.png
- *_consensus_neighbors.png
- *_sample_status.tsv (subset metadata)
Usage:
    python Plot_GM_context.py --ctx-dir synteny_context_mortality_COGs --mode both
"""

import os
import re
import argparse
import pandas as pd
import numpy as np
import pickle

# Use a non-interactive backend to avoid Qt/Wayland errors when saving figures
import matplotlib
if os.environ.get("MPLBACKEND", "") == "":
    matplotlib.use("Agg")

import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path

def _read_cluster_files(ctx_dir: str, cluster: str):
    """Load context + signature + consensus neighbor files for a given cluster."""
    ctx_path = os.path.join(ctx_dir, f"{cluster}_synteny.tsv")
    prod_sig_path = os.path.join(ctx_dir, f"{cluster}_signatures.tsv")
    clust_sig_path = os.path.join(ctx_dir, f"{cluster}_cluster_signatures.tsv")
    cons_path = os.path.join(ctx_dir, f"{cluster}_consensus_context.tsv")
    if not os.path.isfile(ctx_path):
        raise FileNotFoundError(f"Missing context file: {ctx_path}")
    ctx_df = pd.read_csv(ctx_path, sep="\t")
    prod_sig = pd.read_csv(prod_sig_path, sep="\t") if os.path.isfile(prod_sig_path) else pd.DataFrame()
    clust_sig = pd.read_csv(clust_sig_path, sep="\t") if os.path.isfile(clust_sig_path) else pd.DataFrame()
    cons_df = pd.read_csv(cons_path, sep="\t") if os.path.isfile(cons_path) else pd.DataFrame()
    return ctx_df, prod_sig, clust_sig, cons_df

def _split_semicolon(s):
    """Split semicolon-delimited field into list; return empty list on NA/blank."""
    if pd.isna(s) or not isinstance(s, str) or s == '':
        return []
    return [x for x in s.split(';') if x != '']

def _auto_window(ctx_df: pd.DataFrame) -> int:
    """Infer plotting window size from maximum number of left/right products present."""
    if ctx_df is None or ctx_df.empty:
        return 1
    def max_len(col: str) -> int:
        if col not in ctx_df.columns:
            return 0
        lens = ctx_df[col].fillna('').map(lambda x: len(_split_semicolon(x)) if isinstance(x, str) else 0)
        m = lens.max() if len(lens) else 0
        return int(m) if pd.notna(m) else 0
    w = max(max_len('left_products'), max_len('right_products'), 1)
    return w

def _sanitize_token(t):
    """Convert token to safe string; blank if NA or 'na'."""
    if t is None or t == '' or str(t).lower() == 'na':
        return ''
    return str(t)

def _write_status_table(out_tsv: str, ctx_df: pd.DataFrame):
    """Write reduced sample status table (metadata columns if present)."""
    cols_available = [c for c in [
        'sample','sample_orig','status','presence_flag','absence_class','missing_neighbor_fraction',
        'gml_neighbors_overlap','near_contig_end','contig','target_id','target_product',
        'gwas_beta','gwas_presence_state','matches_gwas_direction'
    ] if c in ctx_df.columns]
    ctx_df[cols_available].to_csv(out_tsv, sep='\t', index=False)

def _build_tile_matrix(ctx_df: pd.DataFrame, cluster: str, mode: str, window: int, include_absent: bool):
    """
    Build tile matrix for plotting.
    mode: 'products' uses product annotations, 'clusters' uses cluster IDs for center context.
    include_absent: whether to include rows with status != 'ok'.
    Returns: samples, matrix, legend tokens, GWAS match flags, row metadata list.
    """
    rows = []
    match_flags = []
    meta = []
    for _, row in ctx_df.iterrows():
        status = row.get('status','')
        if status != 'ok' and not include_absent:
            continue
        sample = row['sample']
        if status == 'ok':
            left = _split_semicolon(row['left_products' if mode == 'products' else 'left_clusters'])
            right = _split_semicolon(row['right_products' if mode == 'products' else 'right_clusters'])
            left = ([''] * (window - len(left))) + left[-window:]
            right = right[:window] + ([''] * (window - len(right)))
            # Center token: product for products mode; the cluster id string for clusters mode
            center = _sanitize_token(row['target_product']) if mode == 'products' else str(cluster)
            tokens = left + [center] + right
        else:
            tokens = [''] * (2 * window + 1)
        rows.append((sample, tokens, status,
                 row.get('presence_flag','unknown'),
                 row.get('matches_gwas_direction',''),
                 row.get('absence_class',''), row.get('missing_neighbor_fraction','')))
        match_flags.append(row.get('matches_gwas_direction',''))
    def sort_key(x):
        sample, tokens, status, pflag, match, aclass, missfrac = x
        mismatch_rank = 0 if str(match) == '1' else (1 if str(match) == '0' else 2)
        status_rank = 0 if status == 'ok' else 1
        # Put more complete rows first
        return (status_rank, mismatch_rank, aclass, pflag, tuple(tokens))
    rows.sort(key=sort_key)
    samples_order = [r[0] for r in rows]
    matrix = [r[1] for r in rows]
    legend = {t for toks in matrix for t in toks if t}
    match_sorted = [r[4] for r in rows]
    meta = [{'status': r[2], 'absence_class': r[5], 'missing_neighbor_fraction': r[6]} for r in rows]
    return samples_order, matrix, legend, match_sorted, meta

def _palette_for_tokens(tokens: list[str]):
    """Assign colors to tokens (products/clusters)."""
    uniq = [t for t in tokens if t]
    base = sns.color_palette('tab20', n_colors=min(20, max(1, len(uniq))))
    if len(uniq) > 20:
        base += sns.color_palette('husl', n_colors=len(uniq) - 20)
    color_map = {'': (0.92, 0.92, 0.92)}
    for t, c in zip(uniq, base):
        color_map[t] = c
    return color_map

# Absence class styling: color, line width, line style
_ABSENCE_BORDER = {
    'annotation_issue': ('gold', 1.2, 'solid'),
    'target_only_missing_or_misannotated': ('orange', 1.2, 'solid'),
    'region_missing': ('black', 1.4, 'solid'),
    'partial_region_loss': ('purple', 1.2, 'dashed'),
    'undetermined': ('gray', 1.0, 'dotted')
}

def _draw_tiles(
    out_png: str,
    cluster: str,
    mode: str,
    samples: list[str],
    matrix: list[list[str]],
    window: int,
    ctx_df: pd.DataFrame,
    color_map: dict,
    match_flags: list,
    row_meta: list[dict],
    gwas_beta: float | None,
    gwas_state: str,
    include_gwas: bool,
    include_absent: bool,
    col_w: float = 1.0,
    row_h: float = 0.35,
    dpi: int = 220,
):
    """Render tile plot with optional GWAS direction and absence context annotations.
    col_w: inches per context column, row_h: inches per sample row, dpi: output DPI.
    """
    n_rows = len(samples)
    if n_rows == 0:
        return
    n_cols = 2 * window + 1
    img = np.ones((n_rows, n_cols, 3), dtype=float)
    for i, toks in enumerate(matrix):
        for j, tok in enumerate(toks):
            img[i, j, :] = color_map.get(tok, (0.6, 0.6, 0.6))

    # Estimate legend size (tokens + optional GWAS + optional absence entries)
    used_tokens = []
    for row in matrix:
        for t in row:
            if t and t not in used_tokens:
                used_tokens.append(t)
    legend_token_count = min(25, len(used_tokens))
    gwas_extra = 3 if include_gwas else 0
    absence_extra = len(_ABSENCE_BORDER) if include_absent else 0
    legend_lines = legend_token_count + gwas_extra + absence_extra
    legend_frac = min(0.45, 0.22 + 0.012 * legend_lines)  # fraction of figure width reserved for legend

    # Compute figure size from content
    fig_width = max(10.0, n_cols * col_w) / max(0.35, (1.0 - legend_frac))
    fig_height = max(5.0, n_rows * row_h)

    fig, ax = plt.subplots(figsize=(fig_width, fig_height))
    # Reserve right margin for legend; a bit of top/bottom for titles/labels
    fig.subplots_adjust(left=0.12, right=1.0 - legend_frac - 0.02, top=0.92, bottom=0.10)

    ax.imshow(img, aspect='auto', interpolation='nearest')

    # Center tile border = GWAS direction match/mismatch (optional)
    if include_gwas:
        for i, (mf, meta) in enumerate(zip(match_flags, row_meta)):
            if meta['status'] != 'ok':
                continue
            if mf == '':
                edge_color = 'lightgray'
            elif str(mf) == '1':
                edge_color = 'green'
            else:
                edge_color = 'red'
            ax.add_patch(plt.Rectangle((window - 0.5, i - 0.5), 1, 1,
                                       fill=False, edgecolor=edge_color, linewidth=1.4))

    # Absent rows full-width border per absence_class (optional)
    if include_absent:
        for i, meta in enumerate(row_meta):
            if meta['status'] == 'ok':
                continue
            aclass = meta['absence_class']
            color, lw, style = _ABSENCE_BORDER.get(aclass, ('gray', 0.8, 'dotted'))
            ax.add_patch(plt.Rectangle((-0.5, i - 0.5), n_cols, 1,
                                       fill=False, edgecolor=color, linewidth=lw, linestyle=style))

    # Row labels with suffix markers
    ylabels = []
    for s, mf, meta in zip(samples, match_flags, row_meta):
        suffix = ''
        if meta['status'] != 'ok':
            if meta['absence_class']:
                suffix += f" [{meta['absence_class']}"
                if meta['missing_neighbor_fraction'] != '':
                    suffix += f";missFrac={meta['missing_neighbor_fraction']}]"
                else:
                    suffix += "]"
            else:
                suffix += " [absent]"
        else:
            if include_gwas:
                if str(mf) == '0':
                    suffix += " !"
                elif str(mf) != '1':
                    suffix += " ?"
        ylabels.append(s + suffix)
    y_fs = 6 if n_rows > 60 else (7 if n_rows > 30 else 8)
    ax.set_yticks(range(n_rows))
    ax.set_yticklabels(ylabels, fontsize=y_fs)
    ax.set_xticks(range(n_cols))
    ax.set_xticklabels([f"{i}" for i in range(-window, window + 1)], fontsize=9)
    ax.set_xlabel("Position relative to target (0 = target)")

    # Title with optional GWAS interpretation
    gwas_txt = ""
    if include_gwas and (gwas_beta is not None) and gwas_state:
        direction_desc = ("presence → higher virulence" if gwas_beta >= 0
                          else "absence → higher virulence")
        gwas_txt = f" | GWAS beta={round(gwas_beta,4)} ({direction_desc})"
    ax.set_title(f"{cluster} synteny ({mode}){gwas_txt}")

    ax.set_xticks(np.arange(-.5, n_cols, 1), minor=True)
    ax.set_yticks(np.arange(-.5, n_rows, 1), minor=True)
    ax.grid(which='minor', color='w', linestyle='-', linewidth=0.3, alpha=0.7)

    # Legend tokens (limit to 25)
    handles = [plt.Line2D([0], [0], marker='s', color='w',
                          markerfacecolor=color_map[t], markersize=8,
                          label=(t[:40] + ('…' if len(t) > 40 else ''))) for t in used_tokens[:legend_token_count]]
    # GWAS legend entries (optional)
    if include_gwas:
        handles += [
            plt.Line2D([0],[0], marker='s', color='w', markerfacecolor='white',
                       markeredgecolor='green', markersize=8, label='GWAS match'),
            plt.Line2D([0],[0], marker='s', color='w', markerfacecolor='white',
                       markeredgecolor='red', markersize=8, label='GWAS mismatch'),
            plt.Line2D([0],[0], marker='s', color='w', markerfacecolor='white',
                       markeredgecolor='lightgray', markersize=8, label='GWAS unknown')
        ]
    # Absence class legend entries (optional)
    if include_absent:
        for aclass, (c, lw, style) in _ABSENCE_BORDER.items():
            handles.append(plt.Line2D([0],[0], marker='s', color='w', markerfacecolor='white',
                                      markeredgecolor=c, linestyle=style, linewidth=lw, markersize=8,
                                      label=f"Absent: {aclass}"))
    if handles:
        # Place legend into reserved right margin
        ax.legend(handles=handles, bbox_to_anchor=(1.002, 1.0), loc='upper left',
                  borderaxespad=0., title="Tokens / Annotations")

    plt.savefig(out_png, dpi=dpi, bbox_inches='tight')
    plt.close()

def _draw_signature_bars(out_png: str, cluster: str, prod_sig: pd.DataFrame, clust_sig: pd.DataFrame, top_n=12, dpi: int = 220):
    """Draw horizontal bar charts for top product and cluster signatures."""
    # Width scales with number of bars, leave room for long labels
    n_bars = max(len(prod_sig.head(top_n)), len(clust_sig.head(top_n)))
    fig_w = max(14, 0.8 * max(8, n_bars))
    fig, axes = plt.subplots(1, 2, figsize=(fig_w, 4.8))
    fig.subplots_adjust(left=0.34, right=0.98, top=0.88, bottom=0.15)
    if not prod_sig.empty:
        df = prod_sig.copy().sort_values('count', ascending=False).head(top_n)
        axes[0].barh(range(len(df)), df['count'], color='#4C78A8')
        axes[0].set_yticks(range(len(df)))
        axes[0].set_yticklabels([s[:100] + ('…' if len(s) > 100 else '') for s in df['signature_products']])
        axes[0].invert_yaxis()
        axes[0].set_title('Product signatures')
    else:
        axes[0].axis('off'); axes[0].set_title('Product signatures (none)')
    if not clust_sig.empty:
        df = clust_sig.copy().sort_values('count', ascending=False).head(top_n)
        axes[1].barh(range(len(df)), df['count'], color='#F58518')
        axes[1].set_yticks(range(len(df)))
        axes[1].set_yticklabels([s[:100] + ('…' if len(s) > 100 else '') for s in df['signature_clusters']])
        axes[1].invert_yaxis()
        axes[1].set_title('Cluster signatures')
    else:
        axes[1].axis('off'); axes[1].set_title('Cluster signatures (none)')
    fig.suptitle(f"{cluster} signature frequencies", y=0.99)
    plt.savefig(out_png, dpi=dpi, bbox_inches='tight')
    plt.close()

def _draw_absence_summary(out_png: str, cluster: str, ctx_df: pd.DataFrame, dpi: int = 220):
    """Plot missing_neighbor_fraction for absent samples (if available)."""
    sub = ctx_df[ctx_df['status'] != 'ok'].copy()
    if 'missing_neighbor_fraction' not in sub.columns or sub.empty:
        return
    sub = sub[sub['missing_neighbor_fraction'].apply(lambda x: str(x) != '' and not pd.isna(x))]
    if sub.empty:
        return
    sub['missing_neighbor_fraction'] = sub['missing_neighbor_fraction'].astype(float)
    fig_w = max(8, len(sub) * 0.55)
    fig, ax = plt.subplots(figsize=(fig_w, 3.4))
    sns.barplot(x='sample', y='missing_neighbor_fraction', hue='absence_class',
                data=sub, palette='Set2', dodge=False, ax=ax)
    plt.setp(ax.get_xticklabels(), rotation=70, ha='right', fontsize=7)
    ax.set_ylabel('Missing neighbor fraction')
    ax.set_xlabel('Sample')
    ax.set_title(f"{cluster} absence context")
    fig.subplots_adjust(left=0.12, right=0.98, top=0.90, bottom=0.42)
    plt.savefig(out_png, dpi=dpi, bbox_inches='tight')
    plt.close()

def _draw_consensus_neighbors(out_png: str, cluster: str, cons_df: pd.DataFrame, dpi: int = 220):
    """Plot frequencies of consensus neighbor clusters among present samples."""
    if cons_df.empty:
        return
    df = cons_df.copy().sort_values('frequency', ascending=False)
    fig_w = max(8, len(df) * 0.55)
    fig, ax = plt.subplots(figsize=(fig_w, 3.2))
    sns.barplot(x='neighbor_cluster', y='frequency', data=df, color='#7E57C2', ax=ax)
    plt.setp(ax.get_xticklabels(), rotation=70, ha='right', fontsize=7)
    ax.set_ylabel('Frequency among present samples')
    ax.set_xlabel('Neighbor cluster')
    ax.set_title(f"{cluster} consensus neighbor clusters")
    fig.subplots_adjust(left=0.12, right=0.98, top=0.90, bottom=0.42)
    plt.savefig(out_png, dpi=dpi, bbox_inches='tight')
    plt.close()

def list_clusters(ctx_dir: str):
    """List cluster IDs by scanning *_synteny.tsv filenames."""
    return sorted(set(re.sub(r'_synteny\.tsv$', '', f)
                      for f in os.listdir(ctx_dir) if f.endswith('_synteny.tsv')))

def _load_sample_name_map(path: str | None) -> dict:
    """Load mapping dict: original sample name -> display name (pickle)."""
    if not path:
        return {}
    try:
        with open(path, 'rb') as f:
            m = pickle.load(f)
        if isinstance(m, dict):
            # Normalize keys/values to strings
            return {str(k): str(v) for k, v in m.items()}
        else:
            print(f"[warn] Sample name dict is not a dict: {type(m)}")
            return {}
    except Exception as e:
        print(f"[warn] Could not load sample name dict from {path}: {e}")
        return {}

def _apply_sample_map_to_df(ctx_df: pd.DataFrame, sample_map: dict) -> pd.DataFrame:
    """Replace ctx_df['sample'] using sample_map, preserving original as 'sample_orig'."""
    if not sample_map or 'sample' not in ctx_df.columns:
        return ctx_df
    remapped = ctx_df['sample'].map(lambda s: sample_map.get(str(s), s))
    if remapped.equals(ctx_df['sample']):
        return ctx_df
    out = ctx_df.copy()
    out['sample_orig'] = out['sample']
    out['sample'] = remapped
    return out

def main():
    """CLI entry point: parse args, iterate clusters, generate plots and summary tables."""
    ap = argparse.ArgumentParser(description="Plot synteny context outputs.")
    ap.add_argument('--ctx-dir', required=True, help='Path to synteny_context_ directory')
    ap.add_argument('--out-dir', default=None, help='Output directory (default: ctx-dir/plots)')
    ap.add_argument('--clusters', nargs='*', default=None, help='Specific clusters to plot (default: all)')
    ap.add_argument('--mode', choices=['both', 'products', 'clusters'], default='both', help='Tile plot mode')
    ap.add_argument('--top-n-sigs', type=int, default=12, help='Top signatures to show in bars')
    ap.add_argument('--include-absent', action='store_true', help='Include absent samples in tile plots (default off)')
    ap.add_argument('--include-gwas', action='store_true', help='Include GWAS annotations (borders/legend/title) in tile plots (default off)')
    # New sizing controls
    ap.add_argument('--tile-col-w', type=float, default=1.05, help='Inches per context column in tile plots')
    ap.add_argument('--tile-row-h', type=float, default=0.38, help='Inches per sample row in tile plots')
    ap.add_argument('--dpi', type=int, default=220, help='Output DPI for all figures')
    # Map sample names using dictionary used in Check_GM_context.py
    ap.add_argument('--sample-name-dict',
                    default='/home/albertotr/OneDrive/Data/Cambridge_Project/Camille_replacements_foldername.pickle',
                    help='Pickle file mapping original sample names to display names')
    args = ap.parse_args()

    ctx_dir = args.ctx_dir
    out_dir = args.out_dir or os.path.join(ctx_dir, 'plots')
    Path(out_dir).mkdir(parents=True, exist_ok=True)

    clusters = args.clusters or list_clusters(ctx_dir)
    if not clusters:
        raise SystemExit(f"No *_synteny.tsv files found under {ctx_dir}")

    # Load mapping once
    sample_map = _load_sample_name_map(args.sample_name_dict)

    for cl in clusters:
        try:
            ctx_df, prod_sig, clust_sig, cons_df = _read_cluster_files(ctx_dir, cl)
        except Exception as e:
            print(f"[warn] Skipping {cl}: {e}")
            continue

        # Apply mapping to all downstream figures
        ctx_df = _apply_sample_map_to_df(ctx_df, sample_map)

        _write_status_table(os.path.join(out_dir, f"{cl}_sample_status.tsv"), ctx_df)
        _draw_signature_bars(os.path.join(out_dir, f"{cl}_signature_bars.png"), cl, prod_sig, clust_sig, args.top_n_sigs, dpi=args.dpi)
        if args.include_absent:
            _draw_absence_summary(os.path.join(out_dir, f"{cl}_absence_summary.png"), cl, ctx_df, dpi=args.dpi)
        _draw_consensus_neighbors(os.path.join(out_dir, f"{cl}_consensus_neighbors.png"), cl, cons_df, dpi=args.dpi)

        window = _auto_window(ctx_df)

        # Cluster-level GWAS beta/state (same for all rows)
        gwas_beta = None
        gwas_state = ''
        if args.include_gwas and ('gwas_beta' in ctx_df.columns):
            # Take first non-null
            gb = ctx_df['gwas_beta'].dropna()
            if not gb.empty:
                gwas_beta = float(gb.iloc[0])
        if args.include_gwas and ('gwas_presence_state' in ctx_df.columns):
            gs = ctx_df['gwas_presence_state'].dropna()
            if not gs.empty:
                gwas_state = str(gs.iloc[0])

        if args.mode in ('both', 'products'):
            samples, matrix, legend, match_flags, meta = _build_tile_matrix(
                ctx_df.copy(), cl, 'products', window, include_absent=args.include_absent)
            cmap = _palette_for_tokens(sorted(list(legend)))
            _draw_tiles(os.path.join(out_dir, f"{cl}_synteny_tiles_products.png"), cl, 'products',
                        samples, matrix, window, ctx_df, cmap, match_flags, meta, gwas_beta, gwas_state,
                        include_gwas=args.include_gwas, include_absent=args.include_absent,
                        col_w=args.tile_col_w, row_h=args.tile_row_h, dpi=args.dpi)
        if args.mode in ('both', 'clusters'):
            samples, matrix, legend, match_flags, meta = _build_tile_matrix(
                ctx_df.copy(), cl, 'clusters', window, include_absent=args.include_absent)
            cmap = _palette_for_tokens(sorted(list(legend)))
            _draw_tiles(os.path.join(out_dir, f"{cl}_synteny_tiles_clusters.png"), cl, 'clusters',
                        samples, matrix, window, ctx_df, cmap, match_flags, meta, gwas_beta, gwas_state,
                        include_gwas=args.include_gwas, include_absent=args.include_absent,
                        col_w=args.tile_col_w, row_h=args.tile_row_h, dpi=args.dpi)

        print(f"[info] Plotted {cl} (absent included={args.include_absent}, gwas included={args.include_gwas})")

if __name__ == "__main__":
    main()